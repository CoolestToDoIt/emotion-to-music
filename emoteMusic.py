# -*- coding: utf-8 -*-
"""emoteMusic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LdcK4Elkfvq3s1QXugBfolprdl3x9XqN
"""

!pip install scikit-learn
!pip install pandas
!pip install nltk
!pip install numpy

import pandas as pd
import nltk

emot_list = pd.read_csv('text.csv')

list_of_tweets = emot_list.loc[:50000, "text"]

emotion_values = emot_list.loc[:50000, "label"]

from nltk.corpus import wordnet as wn
nltk.download("wordnet")
import numpy as np

EMOTIONS = ["sadness", "joy", "love", "anger", "fear", "surprise"]
common_nonconnotation = {"the", "as", "a", "an", "in", "of", "but", "and", "is", "i"}

def find_similarity(word, emotion):
    try:
        wor = wn.synsets(word)[0]
    except:
        return 0
    allscore = []
    for meanin in wn.synsets(emotion):
        allscore.append(wor.path_similarity(meanin))
    allscore.sort(reverse=True)
    return allscore[0]

def get_word_emotion(word):
    if word not in common_nonconnotation:
        similarities = []
        for emotion in EMOTIONS:
            distance = find_similarity(word, emotion)
            similarities += [distance]
        return similarities
    return [0,0,0,0,0,0]

def normalize_array(array):
    norm = np.linalg.norm(array)
    if norm == 0:
       return array
    return array / norm

def tweet_emotion_array(tweet):
    fin_arr = np.array([0,0,0,0,0,0])
    for word in tweet:
      word.lower()
      new_arr = np.array(get_word_emotion(word))
    fin_arr = np.add(fin_arr, new_arr)
    return fin_arr

data = []
for tweet in list_of_tweets:
    data += [tweet_emotion_array(tweet)]

from sklearn.model_selection import train_test_split
import time
from sklearn import svm
clf = svm.SVC()

x_train, x_test, y_train, y_test = train_test_split(data, emotion_values, test_size=0.33, random_state=42)

st_train = time.perf_counter()
clf.fit(x_train, y_train)
ed_train = time.perf_counter()

right = 0
st_test = time.perf_counter()
for n in range(len(x_test)):
    if clf.predict([x_test[n]]) == y_test.iloc[n]:
        right+=1
ed_test = time.perf_counter()

print("Train time:", ed_train-st_train, "\nTest time:", ed_test-st_test, "\nCorrectness:", right/len(y_test))

endpoint_url = "https://api.spotify.com/v1/recommendations?"
token = ""
user_id = ""

emotion_responses = []
seed_tracks={"sadness":'1ONoPkp5XIuw3tZ1GzrNKZ',"joy":'4y5bvROuBDPr5fuwXbIBZR', "love":'0tgVpDi06FyKpA1z0VMD4v', "anger":'56sk7jBpZV0CD31G9hEU3b', "fear":'1g10rYqM3jJQsWRnXCFcx7', "surprise":'2McQQA5nCLVL0XvzcxWhFC'}
uris = []

emote_val = clf.predict(tweet_emotion_array(input()))

emotion = ""
if emote_val == 0:
  emotion = "sadness"
elif emote_val == 1:
  emotion = "joy"
elif emote_val == 2:
  emotion = "love"
elif emote_val == 3:
  emotion = "anger"
elif emote_val == 4:
  emotion = "fear"
else:
  emotion = "surprise"

# OUR FILTERS

limit=15
market="US"

# PERFORM THE QUERY
query = f'{endpoint_url}limit={limit}&market={market}'
query += f'&seed_tracks={seed_tracks[emotion]}'

response = requests.get(query,
            headers={"Content-Type":"application/json",
                        "Authorization":f"Bearer {token}"})
emotion_responses.append(response.json())

print('Recommended Songs:')
for json_response in emotion_responses:
    for i,j in enumerate(json_response['tracks']):
                uris.append(j['uri'])
                print(f"{i+1}) \"{j['name']}\" by {j['artists'][0]['name']}")

#Create the playlist

endpoint_url = f"https://api.spotify.com/v1/users/{user_id}/playlists"

request_body = json.dumps({
          "name": "MusingTheMusic",
          "description": "MusingTheMusic",
          "public": True
        })
response = requests.post(url = endpoint_url, data = request_body, headers={"Content-Type":"application/json",
                        "Authorization":f"Bearer {token}"})

url = response.json()['external_urls']['spotify']
print(response.status_code)

#Fill the playlist

playlist_id = response.json()['id']

endpoint_url = f"https://api.spotify.com/v1/playlists/{playlist_id}/tracks"

request_body = json.dumps({
          "uris" : uris
        })
response = requests.post(url = endpoint_url, data = request_body, headers={"Content-Type":"application/json",
                        "Authorization":f"Bearer {token}"})

print(response.status_code)

print(f'Your playlist is ready at {url}')
